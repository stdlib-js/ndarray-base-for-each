{"version":3,"file":"index.mjs","sources":["../lib/nd_accessors.js","../lib/nd.js","../lib/main.js","../lib/0d.js","../lib/1d.js","../lib/2d.js","../lib/3d.js","../lib/4d.js","../lib/5d.js","../lib/6d.js","../lib/7d.js","../lib/8d.js","../lib/9d.js","../lib/10d.js","../lib/0d_accessors.js","../lib/1d_accessors.js","../lib/2d_accessors.js","../lib/3d_accessors.js","../lib/4d_accessors.js","../lib/5d_accessors.js","../lib/6d_accessors.js","../lib/7d_accessors.js","../lib/8d_accessors.js","../lib/9d_accessors.js","../lib/10d_accessors.js","../lib/2d_blocked.js","../lib/3d_blocked.js","../lib/4d_blocked.js","../lib/5d_blocked.js","../lib/6d_blocked.js","../lib/7d_blocked.js","../lib/8d_blocked.js","../lib/9d_blocked.js","../lib/10d_blocked.js","../lib/2d_blocked_accessors.js","../lib/3d_blocked_accessors.js","../lib/4d_blocked_accessors.js","../lib/5d_blocked_accessors.js","../lib/6d_blocked_accessors.js","../lib/7d_blocked_accessors.js","../lib/8d_blocked_accessors.js","../lib/9d_blocked_accessors.js","../lib/10d_blocked_accessors.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport ind2sub from '@stdlib/ndarray-base-ind2sub';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEachnd( x, fcn, {} );\n*/\nfunction forEachnd( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ordx;\n\tvar len;\n\tvar get;\n\tvar idx;\n\tvar sh;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i;\n\n\tsh = x.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Cache a reference to the output ndarray data buffer:\n\txbuf = x.data;\n\n\t// Cache a reference to the stride array:\n\tsx = x.strides;\n\n\t// Cache the index of the first indexed element:\n\tox = x.offset;\n\n\t// Cache the array order:\n\tordx = x.order;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over each element based on the linear **view** index, regardless as to how the data is stored in memory...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tix = vind2bind( sh, sx, ox, ordx, i, MODE );\n\t\tidx = ind2sub( sh, sx, 0, ordx, i, MODE ); // return subscripts from the perspective of the ndarray view\n\t\tfcn.call( thisArg, get( xbuf, ix ), idx, x.ref );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEachnd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport ind2sub from '@stdlib/ndarray-base-ind2sub';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEachnd( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEachnd( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar ordx;\n\tvar len;\n\tvar idx;\n\tvar sh;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i;\n\n\tsh = x.shape;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( sh );\n\n\t// Cache a reference to the output ndarray data buffer:\n\txbuf = x.data;\n\n\t// Cache a reference to the stride array:\n\tsx = x.strides;\n\n\t// Cache the index of the first indexed element:\n\tox = x.offset;\n\n\t// Cache the array order:\n\tordx = x.order;\n\n\t// Iterate over each element based on the linear **view** index, regardless as to how the data is stored in memory...\n\tfor ( i = 0; i < len; i++ ) {\n\t\tix = vind2bind( sh, sx, ox, ordx, i, MODE );\n\t\tidx = ind2sub( sh, sx, 0, ordx, i, MODE ); // return subscripts from the perspective of the ndarray view\n\t\tfcn.call( thisArg, xbuf[ ix ], idx, x.ref );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEachnd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport iterationOrder from '@stdlib/ndarray-base-iteration-order';\nimport ndarray2object from '@stdlib/ndarray-base-ndarraylike2object';\nimport numel from '@stdlib/ndarray-base-numel';\nimport blockedaccessorForEach2d from './2d_blocked_accessors.js';\nimport blockedaccessorForEach3d from './3d_blocked_accessors.js';\nimport blockedaccessorForEach4d from './4d_blocked_accessors.js';\nimport blockedaccessorForEach5d from './5d_blocked_accessors.js';\nimport blockedaccessorForEach6d from './6d_blocked_accessors.js';\nimport blockedaccessorForEach7d from './7d_blocked_accessors.js';\nimport blockedaccessorForEach8d from './8d_blocked_accessors.js';\nimport blockedaccessorForEach9d from './9d_blocked_accessors.js';\nimport blockedaccessorForEach10d from './10d_blocked_accessors.js';\nimport blockedForEach2d from './2d_blocked.js';\nimport blockedForEach3d from './3d_blocked.js';\nimport blockedForEach4d from './4d_blocked.js';\nimport blockedForEach5d from './5d_blocked.js';\nimport blockedForEach6d from './6d_blocked.js';\nimport blockedForEach7d from './7d_blocked.js';\nimport blockedForEach8d from './8d_blocked.js';\nimport blockedForEach9d from './9d_blocked.js';\nimport blockedForEach10d from './10d_blocked.js';\nimport accessorForEach0d from './0d_accessors.js';\nimport accessorForEach1d from './1d_accessors.js';\nimport accessorForEach2d from './2d_accessors.js';\nimport accessorForEach3d from './3d_accessors.js';\nimport accessorForEach4d from './4d_accessors.js';\nimport accessorForEach5d from './5d_accessors.js';\nimport accessorForEach6d from './6d_accessors.js';\nimport accessorForEach7d from './7d_accessors.js';\nimport accessorForEach8d from './8d_accessors.js';\nimport accessorForEach9d from './9d_accessors.js';\nimport accessorForEach10d from './10d_accessors.js';\nimport accessorForEachnd from './nd_accessors.js';\nimport forEach0d from './0d.js';\nimport forEach1d from './1d.js';\nimport forEach2d from './2d.js';\nimport forEach3d from './3d.js';\nimport forEach4d from './4d.js';\nimport forEach5d from './5d.js';\nimport forEach6d from './6d.js';\nimport forEach7d from './7d.js';\nimport forEach8d from './8d.js';\nimport forEach9d from './9d.js';\nimport forEach10d from './10d.js';\nimport forEachnd from './nd.js';\n\n\n// VARIABLES //\n\nvar FOR_EACH = [\n\tforEach0d,\n\tforEach1d,\n\tforEach2d,\n\tforEach3d,\n\tforEach4d,\n\tforEach5d,\n\tforEach6d,\n\tforEach7d,\n\tforEach8d,\n\tforEach9d,\n\tforEach10d\n];\nvar ACCESSOR_FOR_EACH = [\n\taccessorForEach0d,\n\taccessorForEach1d,\n\taccessorForEach2d,\n\taccessorForEach3d,\n\taccessorForEach4d,\n\taccessorForEach5d,\n\taccessorForEach6d,\n\taccessorForEach7d,\n\taccessorForEach8d,\n\taccessorForEach9d,\n\taccessorForEach10d\n];\nvar BLOCKED_FOR_EACH = [\n\tblockedForEach2d, // 0\n\tblockedForEach3d,\n\tblockedForEach4d,\n\tblockedForEach5d,\n\tblockedForEach6d,\n\tblockedForEach7d,\n\tblockedForEach8d,\n\tblockedForEach9d,\n\tblockedForEach10d // 8\n];\nvar BLOCKED_ACCESSOR_FOR_EACH = [\n\tblockedaccessorForEach2d, // 0\n\tblockedaccessorForEach3d,\n\tblockedaccessorForEach4d,\n\tblockedaccessorForEach5d,\n\tblockedaccessorForEach6d,\n\tblockedaccessorForEach7d,\n\tblockedaccessorForEach8d,\n\tblockedaccessorForEach9d,\n\tblockedaccessorForEach10d // 8\n];\nvar MAX_DIMS = FOR_EACH.length - 1;\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* ## Notes\n*\n* -   A provided ndarray should be an `object` with the following properties:\n*\n*     -   **dtype**: data type.\n*     -   **data**: data buffer.\n*     -   **shape**: dimensions.\n*     -   **strides**: stride lengths.\n*     -   **offset**: index offset.\n*     -   **order**: specifies whether an ndarray is row-major (C-style) or column major (Fortran-style).\n*\n* @param {ArrayLikeObject<Object>} arrays - array-like object containing one input array\n* @param {Callback} fcn - callback function\n* @param {*} [thisArg] - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach( [ x ], naryFunction( log, 1 ) );\n*/\nfunction forEach( arrays, fcn, thisArg ) {\n\tvar ndims;\n\tvar shx;\n\tvar x;\n\n\t// Unpack the ndarray and standardize ndarray meta data:\n\tx = ndarray2object( arrays[ 0 ] );\n\tshx = x.shape;\n\tndims = shx.length;\n\n\t// Determine whether we can avoid iteration altogether...\n\tif ( ndims === 0 ) {\n\t\tif ( x.accessorProtocol ) {\n\t\t\treturn ACCESSOR_FOR_EACH[ ndims ]( x, fcn, thisArg );\n\t\t}\n\t\treturn FOR_EACH[ ndims ]( x, fcn, thisArg );\n\t}\n\t// Check whether we were provided an empty ndarray...\n\tif ( numel( shx ) === 0 ) {\n\t\treturn;\n\t}\n\t// Determine whether we can avoid blocked iteration...\n\tif ( ndims <= MAX_DIMS && iterationOrder( x.strides ) !== 0 ) {\n\t\t// So long as iteration always moves in the same direction (i.e., no mixed sign strides), we can leverage cache-optimal (i.e., normal) nested loops without resorting to blocked iteration...\n\t\tif ( x.accessorProtocol ) {\n\t\t\treturn ACCESSOR_FOR_EACH[ ndims ]( x, fcn, thisArg );\n\t\t}\n\t\treturn FOR_EACH[ ndims ]( x, fcn, thisArg );\n\t}\n\t// Determine whether we can perform blocked iteration...\n\tif ( ndims <= MAX_DIMS ) {\n\t\tif ( x.accessorProtocol ) {\n\t\t\treturn BLOCKED_ACCESSOR_FOR_EACH[ ndims-2 ]( x, fcn, thisArg );\n\t\t}\n\t\treturn BLOCKED_FOR_EACH[ ndims-2 ]( x, fcn, thisArg );\n\t}\n\t// Fall-through to linear view iteration without regard for how data is stored in memory (i.e., take the slow path)...\n\tif ( x.accessorProtocol ) {\n\t\treturn accessorForEachnd( x, fcn, thisArg );\n\t}\n\tforEachnd( x, fcn, thisArg );\n}\n\n\n// EXPORTS //\n\nexport default forEach;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 2 );\n*\n* // Define the shape of the array:\n* var shape = [];\n*\n* // Define the array strides:\n* var sx = [ 0 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach0d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach0d( x, fcn, thisArg ) {\n\tfcn.call( thisArg, x.data[ x.offset ], [], x.ref );\n}\n\n\n// EXPORTS //\n\nexport default forEach0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 4 ];\n*\n* // Define the array strides:\n* var sx = [ 2 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach1d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach1d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar S0;\n\tvar ix;\n\tvar i0;\n\n\t// Note on variable naming convention: S#, dx#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables: dimensions and loop offset (pointer) increments:\n\tS0 = x.shape[ 0 ];\n\tdx0 = x.strides[ 0 ];\n\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tfcn.call( thisArg, xbuf[ ix ], [ i0 ], x.ref );\n\t\tix += dx0;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach2d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach2d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdx0 = sx[ 1 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 0 ] - ( S0*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i1, i0 ], idx ), x.ref );\n\t\t\tix += dx0;\n\t\t}\n\t\tix += dx1;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach3d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach3d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdx0 = sx[ 2 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx2 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\tix += dx0;\n\t\t\t}\n\t\t\tix += dx1;\n\t\t}\n\t\tix += dx2;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach4d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach4d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdx0 = sx[ 3 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 2 ] - ( S0*sx[3] );\n\t\tdx2 = sx[ 1 ] - ( S1*sx[2] );\n\t\tdx3 = sx[ 0 ] - ( S2*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\tix += dx0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t}\n\t\t\tix += dx2;\n\t\t}\n\t\tix += dx3;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach5d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach5d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdx0 = sx[ 4 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 3 ] - ( S0*sx[4] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[3] );\n\t\tdx3 = sx[ 1 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 0 ] - ( S3*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx1;\n\t\t\t\t}\n\t\t\t\tix += dx2;\n\t\t\t}\n\t\t\tix += dx3;\n\t\t}\n\t\tix += dx4;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach6d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach6d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdx0 = sx[ 5 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 4 ] - ( S0*sx[5] );\n\t\tdx2 = sx[ 3 ] - ( S1*sx[4] );\n\t\tdx3 = sx[ 2 ] - ( S2*sx[3] );\n\t\tdx4 = sx[ 1 ] - ( S3*sx[2] );\n\t\tdx5 = sx[ 0 ] - ( S4*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t}\n\t\t\t\tix += dx3;\n\t\t\t}\n\t\t\tix += dx4;\n\t\t}\n\t\tix += dx5;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach7d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach7d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdx0 = sx[ 6 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 5 ] - ( S0*sx[6] );\n\t\tdx2 = sx[ 4 ] - ( S1*sx[5] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[4] );\n\t\tdx4 = sx[ 2 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 1 ] - ( S4*sx[2] );\n\t\tdx6 = sx[ 0 ] - ( S5*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx3;\n\t\t\t\t}\n\t\t\t\tix += dx4;\n\t\t\t}\n\t\t\tix += dx5;\n\t\t}\n\t\tix += dx6;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach8d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach8d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdx0 = sx[ 7 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 6 ] - ( S0*sx[7] );\n\t\tdx2 = sx[ 5 ] - ( S1*sx[6] );\n\t\tdx3 = sx[ 4 ] - ( S2*sx[5] );\n\t\tdx4 = sx[ 3 ] - ( S3*sx[4] );\n\t\tdx5 = sx[ 2 ] - ( S4*sx[3] );\n\t\tdx6 = sx[ 1 ] - ( S5*sx[2] );\n\t\tdx7 = sx[ 0 ] - ( S6*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx4;\n\t\t\t\t}\n\t\t\t\tix += dx5;\n\t\t\t}\n\t\t\tix += dx6;\n\t\t}\n\t\tix += dx7;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach9d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach9d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdx0 = sx[ 8 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 7 ] - ( S0*sx[8] );\n\t\tdx2 = sx[ 6 ] - ( S1*sx[7] );\n\t\tdx3 = sx[ 5 ] - ( S2*sx[6] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[5] );\n\t\tdx5 = sx[ 3 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 2 ] - ( S5*sx[3] );\n\t\tdx7 = sx[ 1 ] - ( S6*sx[2] );\n\t\tdx8 = sx[ 0 ] - ( S7*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx5;\n\t\t\t\t}\n\t\t\t\tix += dx6;\n\t\t\t}\n\t\t\tix += dx7;\n\t\t}\n\t\tix += dx8;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* forEach10d( x, naryFunction( log, 1 ), {} );\n*/\nfunction forEach10d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdx0 = sx[ 9 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 8 ] - ( S0*sx[9] );\n\t\tdx2 = sx[ 7 ] - ( S1*sx[8] );\n\t\tdx3 = sx[ 6 ] - ( S2*sx[7] );\n\t\tdx4 = sx[ 5 ] - ( S3*sx[6] );\n\t\tdx5 = sx[ 4 ] - ( S4*sx[5] );\n\t\tdx6 = sx[ 3 ] - ( S5*sx[4] );\n\t\tdx7 = sx[ 2 ] - ( S6*sx[3] );\n\t\tdx8 = sx[ 1 ] - ( S7*sx[2] );\n\t\tdx9 = sx[ 0 ] - ( S8*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] );\n\t\tdx9 = sx[ 9 ] - ( S8*sx[8] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx6;\n\t\t\t\t}\n\t\t\t\tix += dx7;\n\t\t\t}\n\t\t\tix += dx8;\n\t\t}\n\t\tix += dx9;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 4 );\n*\n* // Define the shape of the array:\n* var shape = [];\n*\n* // Define the array strides:\n* var sx = [ 0 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach0d( x, fcn, {} );\n*/\nfunction forEach0d( x, fcn, thisArg ) {\n\tfcn.call( thisArg, x.accessors[ 0 ]( x.data, x.offset ), [], x.ref );\n}\n\n\n// EXPORTS //\n\nexport default forEach0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 4 ];\n*\n* // Define the array strides:\n* var sx = [ 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach1d( x, fcn, {} );\n*/\nfunction forEach1d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar S0;\n\tvar ix;\n\tvar i0;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables: dimensions and loop offset (pointer) increments...\n\tS0 = x.shape[ 0 ];\n\tdx0 = x.strides[ 0 ];\n\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tfcn.call( thisArg, get( xbuf, ix ), [ i0 ], x.ref );\n\t\tix += dx0;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach2d( x, fcn, {} );\n*/\nfunction forEach2d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 1 ];\n\t\tS1 = sh[ 0 ];\n\t\tdx0 = sx[ 1 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 0 ] - ( S0*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\tix += dx0;\n\t\t}\n\t\tix += dx1;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach3d( x, fcn, {} );\n*/\nfunction forEach3d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 2 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 0 ];\n\t\tdx0 = sx[ 2 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[2] );\n\t\tdx2 = sx[ 0 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\tix += dx0;\n\t\t\t}\n\t\t\tix += dx1;\n\t\t}\n\t\tix += dx2;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach4d( x, fcn, {} );\n*/\nfunction forEach4d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 3 ];\n\t\tS1 = sh[ 2 ];\n\t\tS2 = sh[ 1 ];\n\t\tS3 = sh[ 0 ];\n\t\tdx0 = sx[ 3 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 2 ] - ( S0*sx[3] );\n\t\tdx2 = sx[ 1 ] - ( S1*sx[2] );\n\t\tdx3 = sx[ 0 ] - ( S2*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\tix += dx0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t}\n\t\t\tix += dx2;\n\t\t}\n\t\tix += dx3;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach5d( x, fcn, {} );\n*/\nfunction forEach5d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 4 ];\n\t\tS1 = sh[ 3 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 1 ];\n\t\tS4 = sh[ 0 ];\n\t\tdx0 = sx[ 4 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 3 ] - ( S0*sx[4] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[3] );\n\t\tdx3 = sx[ 1 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 0 ] - ( S3*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx1;\n\t\t\t\t}\n\t\t\t\tix += dx2;\n\t\t\t}\n\t\t\tix += dx3;\n\t\t}\n\t\tix += dx4;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach6d( x, fcn, {} );\n*/\nfunction forEach6d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 5 ];\n\t\tS1 = sh[ 4 ];\n\t\tS2 = sh[ 3 ];\n\t\tS3 = sh[ 2 ];\n\t\tS4 = sh[ 1 ];\n\t\tS5 = sh[ 0 ];\n\t\tdx0 = sx[ 5 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 4 ] - ( S0*sx[5] );\n\t\tdx2 = sx[ 3 ] - ( S1*sx[4] );\n\t\tdx3 = sx[ 2 ] - ( S2*sx[3] );\n\t\tdx4 = sx[ 1 ] - ( S3*sx[2] );\n\t\tdx5 = sx[ 0 ] - ( S4*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t}\n\t\t\t\tix += dx3;\n\t\t\t}\n\t\t\tix += dx4;\n\t\t}\n\t\tix += dx5;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach7d( x, fcn, {} );\n*/\nfunction forEach7d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 6 ];\n\t\tS1 = sh[ 5 ];\n\t\tS2 = sh[ 4 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 2 ];\n\t\tS5 = sh[ 1 ];\n\t\tS6 = sh[ 0 ];\n\t\tdx0 = sx[ 6 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 5 ] - ( S0*sx[6] );\n\t\tdx2 = sx[ 4 ] - ( S1*sx[5] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[4] );\n\t\tdx4 = sx[ 2 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 1 ] - ( S4*sx[2] );\n\t\tdx6 = sx[ 0 ] - ( S5*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx3;\n\t\t\t\t}\n\t\t\t\tix += dx4;\n\t\t\t}\n\t\t\tix += dx5;\n\t\t}\n\t\tix += dx6;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach8d( x, fcn, {} );\n*/\nfunction forEach8d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 7 ];\n\t\tS1 = sh[ 6 ];\n\t\tS2 = sh[ 5 ];\n\t\tS3 = sh[ 4 ];\n\t\tS4 = sh[ 3 ];\n\t\tS5 = sh[ 2 ];\n\t\tS6 = sh[ 1 ];\n\t\tS7 = sh[ 0 ];\n\t\tdx0 = sx[ 7 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 6 ] - ( S0*sx[7] );\n\t\tdx2 = sx[ 5 ] - ( S1*sx[6] );\n\t\tdx3 = sx[ 4 ] - ( S2*sx[5] );\n\t\tdx4 = sx[ 3 ] - ( S3*sx[4] );\n\t\tdx5 = sx[ 2 ] - ( S4*sx[3] );\n\t\tdx6 = sx[ 1 ] - ( S5*sx[2] );\n\t\tdx7 = sx[ 0 ] - ( S6*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx4;\n\t\t\t\t}\n\t\t\t\tix += dx5;\n\t\t\t}\n\t\t\tix += dx6;\n\t\t}\n\t\tix += dx7;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach9d( x, fcn, {} );\n*/\nfunction forEach9d( x, fcn, thisArg ) {\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 8 ];\n\t\tS1 = sh[ 7 ];\n\t\tS2 = sh[ 6 ];\n\t\tS3 = sh[ 5 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 3 ];\n\t\tS6 = sh[ 2 ];\n\t\tS7 = sh[ 1 ];\n\t\tS8 = sh[ 0 ];\n\t\tdx0 = sx[ 8 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 7 ] - ( S0*sx[8] );\n\t\tdx2 = sx[ 6 ] - ( S1*sx[7] );\n\t\tdx3 = sx[ 5 ] - ( S2*sx[6] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[5] );\n\t\tdx5 = sx[ 3 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 2 ] - ( S5*sx[3] );\n\t\tdx7 = sx[ 1 ] - ( S6*sx[2] );\n\t\tdx8 = sx[ 0 ] - ( S7*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx5;\n\t\t\t\t}\n\t\t\t\tix += dx6;\n\t\t\t}\n\t\t\tix += dx7;\n\t\t}\n\t\tix += dx8;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport reverse from '@stdlib/array-base-reverse';\nimport take from '@stdlib/array-base-take-indexed';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* forEach10d( x, fcn, {} );\n*/\nfunction forEach10d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar idx;\n\tvar sh;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sx;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\n\t// Note on variable naming convention: S#, dx#, dy#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tsh = x.shape;\n\tsx = x.strides;\n\tidx = zeroTo( sh.length );\n\tif ( strides2order( sx ) === 1 ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = sh[ 9 ];\n\t\tS1 = sh[ 8 ];\n\t\tS2 = sh[ 7 ];\n\t\tS3 = sh[ 6 ];\n\t\tS4 = sh[ 5 ];\n\t\tS5 = sh[ 4 ];\n\t\tS6 = sh[ 3 ];\n\t\tS7 = sh[ 2 ];\n\t\tS8 = sh[ 1 ];\n\t\tS9 = sh[ 0 ];\n\t\tdx0 = sx[ 9 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 8 ] - ( S0*sx[9] );\n\t\tdx2 = sx[ 7 ] - ( S1*sx[8] );\n\t\tdx3 = sx[ 6 ] - ( S2*sx[7] );\n\t\tdx4 = sx[ 5 ] - ( S3*sx[6] );\n\t\tdx5 = sx[ 4 ] - ( S4*sx[5] );\n\t\tdx6 = sx[ 3 ] - ( S5*sx[4] );\n\t\tdx7 = sx[ 2 ] - ( S6*sx[3] );\n\t\tdx8 = sx[ 1 ] - ( S7*sx[2] );\n\t\tdx9 = sx[ 0 ] - ( S8*sx[1] ); // offset increment for outermost loop\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = sh[ 0 ];\n\t\tS1 = sh[ 1 ];\n\t\tS2 = sh[ 2 ];\n\t\tS3 = sh[ 3 ];\n\t\tS4 = sh[ 4 ];\n\t\tS5 = sh[ 5 ];\n\t\tS6 = sh[ 6 ];\n\t\tS7 = sh[ 7 ];\n\t\tS8 = sh[ 8 ];\n\t\tS9 = sh[ 9 ];\n\t\tdx0 = sx[ 0 ];                // offset increment for innermost loop\n\t\tdx1 = sx[ 1 ] - ( S0*sx[0] );\n\t\tdx2 = sx[ 2 ] - ( S1*sx[1] );\n\t\tdx3 = sx[ 3 ] - ( S2*sx[2] );\n\t\tdx4 = sx[ 4 ] - ( S3*sx[3] );\n\t\tdx5 = sx[ 5 ] - ( S4*sx[4] );\n\t\tdx6 = sx[ 6 ] - ( S5*sx[5] );\n\t\tdx7 = sx[ 7 ] - ( S6*sx[6] );\n\t\tdx8 = sx[ 8 ] - ( S7*sx[7] );\n\t\tdx9 = sx[ 9 ] - ( S8*sx[8] ); // offset increment for outermost loop\n\t\tidx = reverse( idx );\n\t}\n\t// Set a pointer to the first indexed element:\n\tix = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache accessor:\n\tget = x.accessors[ 0 ];\n\n\t// Iterate over the ndarray dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx6;\n\t\t\t\t}\n\t\t\t\tix += dx7;\n\t\t\t}\n\t\t\tix += dx8;\n\t\t}\n\t\tix += dx9;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default forEach10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach2d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach2d( x, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar ox1;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tox1 = ox + ( j1*sx[1] );\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t// Compute the loop offset increment:\n\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t// Iterate over the ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\tix += dx0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach3d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach3d( x, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar ox1;\n\tvar ox2;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tox2 = ox + ( j2*sx[2] );\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t// Compute the loop offset increment:\n\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach4d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach4d( x, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tox3 = ox + ( j3*sx[3] );\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach5d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach5d( x, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tox4 = ox + ( j4*sx[4] );\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach6d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach6d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tox5 = ox + ( j5*sx[5] );\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach7d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach7d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tox6 = ox + ( j6*sx[6] );\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach8d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach8d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tox7 = ox + ( j7*sx[7] );\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach9d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach9d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tox8 = ox + ( j8*sx[8] );\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import naryFunction from '@stdlib/utils-nary-function';\n* import log from '@stdlib/console-log';\n*\n* // Create a data buffer:\n* var xbuf = new Float64Array( 12 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 3, 1, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 4, 1 ];\n*\n* // Define the index offset:\n* var ox = 1;\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Apply the callback function:\n* blockedforEach10d( x, naryFunction( log, 1 ), {} );\n*/\nfunction blockedforEach10d( x, fcn, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar ox9;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tox9 = ox + ( j9*sx[9] );\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tdx9 = sx[9] - ( s8*sx[8] );\n\t\t\tox8 = ox9 + ( j8*sx[8] );\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, xbuf[ ix ], take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach2d( x, fcn, {} );\n*/\nfunction blockedforEach2d( x, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar ox1;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tox1 = ox + ( j1*sx[1] );\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t// Compute the loop offset increment:\n\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t// Iterate over the ndarray dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\tix += dx0;\n\t\t\t\t}\n\t\t\t\tix += dx1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach3d( x, fcn, {} );\n*/\nfunction blockedforEach3d( x, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar ox1;\n\tvar ox2;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tox2 = ox + ( j2*sx[2] );\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t// Compute the loop offset increment:\n\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t}\n\t\t\t\t\tix += dx2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach4d( x, fcn, {} );\n*/\nfunction blockedforEach4d( x, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tox3 = ox + ( j3*sx[3] );\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach5d( x, fcn, {} );\n*/\nfunction blockedforEach5d( x, fcn, thisArg ) {\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tox4 = ox + ( j4*sx[4] );\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach6d( x, fcn, {} );\n*/\nfunction blockedforEach6d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tox5 = ox + ( j5*sx[5] );\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i5, i4, i3, i2, i1, i0 ], idx ), x.ref ); // eslint-disable-line max-len\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach7d( x, fcn, {} );\n*/\nfunction blockedforEach7d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tox6 = ox + ( j6*sx[6] );\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach8d( x, fcn, {} );\n*/\nfunction blockedforEach8d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tox7 = ox + ( j7*sx[7] );\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach9d( x, fcn, {} );\n*/\nfunction blockedforEach9d( x, fcn, thisArg ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tox8 = ox + ( j8*sx[8] );\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-nullary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-nullary-tiling-block-size';\nimport take from '@stdlib/array-base-take-indexed';\nimport reverse from '@stdlib/array-base-reverse';\n\n\n// MAIN //\n\n/**\n* Invokes a callback function once for each ndarray element via loop blocking.\n*\n* @private\n* @param {Object} x - object containing ndarray meta data\n* @param {ndarrayLike} x.ref - reference to the original ndarray-like object\n* @param {string} x.dtype - data type\n* @param {Collection} x.data - data buffer\n* @param {NonNegativeIntegerArray} x.shape - dimensions\n* @param {IntegerArray} x.strides - stride lengths\n* @param {NonNegativeInteger} x.offset - index offset\n* @param {string} x.order - specifies whether `x` is row-major (C-style) or column-major (Fortran-style)\n* @param {Array<Function>} x.accessors - data buffer accessors\n* @param {Callback} fcn - callback function\n* @param {*} thisArg - callback function execution context\n* @returns {void}\n*\n* @example\n* import Complex64Array from '@stdlib/array-complex64';\n* import log from '@stdlib/console-log';\n*\n* function fcn( value ) {\n*     log( '%s', value.toString() );\n* }\n*\n* // Create a data buffer:\n* var xbuf = new Complex64Array( 8 );\n*\n* // Define the shape of the array:\n* var shape = [ 1, 1, 1, 1, 1, 1, 1, 1, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 4, 4, 4, 4, 4, 4, 4, 2, 1 ];\n*\n* // Define the index offset:\n* var ox = 0;\n*\n* // Define getters and setters:\n* function getter( buf, idx ) {\n*     return buf.get( idx );\n* }\n*\n* function setter( buf, idx, value ) {\n*     buf.set( value, idx );\n* }\n*\n* // Create an ndarray-like object:\n* var x = {\n*     'ref': null,\n*     'dtype': 'complex64',\n*     'data': xbuf,\n*     'shape': shape,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major',\n*     'accessors': [ getter, setter ]\n* };\n*\n* // Apply the callback function:\n* blockedforEach10d( x, fcn, {} );\n*/\nfunction blockedforEach10d( x, fcn, thisArg ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar xbuf;\n\tvar get;\n\tvar dx0;\n\tvar dx1;\n\tvar dx2;\n\tvar dx3;\n\tvar dx4;\n\tvar dx5;\n\tvar dx6;\n\tvar dx7;\n\tvar dx8;\n\tvar dx9;\n\tvar ox1;\n\tvar ox2;\n\tvar ox3;\n\tvar ox4;\n\tvar ox5;\n\tvar ox6;\n\tvar ox7;\n\tvar ox8;\n\tvar ox9;\n\tvar idx;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sx;\n\tvar ox;\n\tvar ix;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar o;\n\n\t// Note on variable naming convention: s#, dx#, dy#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( x.shape, x.strides );\n\tsh = o.sh;\n\tsx = o.sx;\n\tidx = reverse( o.idx );\n\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype );\n\n\t// Set a pointer to the first indexed element:\n\tox = x.offset;\n\n\t// Cache a reference to the output ndarray buffer:\n\txbuf = x.data;\n\n\t// Cache the offset increment for the innermost loop:\n\tdx0 = sx[0];\n\n\t// Cache accessor:\n\tget = x.accessors[0];\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tox9 = ox + ( j9*sx[9] );\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tdx9 = sx[9] - ( s8*sx[8] );\n\t\t\tox8 = ox9 + ( j8*sx[8] );\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tdx8 = sx[8] - ( s7*sx[7] );\n\t\t\t\tox7 = ox8 + ( j7*sx[7] );\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tdx7 = sx[7] - ( s6*sx[6] );\n\t\t\t\t\tox6 = ox7 + ( j6*sx[6] );\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdx6 = sx[6] - ( s5*sx[5] );\n\t\t\t\t\t\tox5 = ox6 + ( j5*sx[5] );\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdx5 = sx[5] - ( s4*sx[4] );\n\t\t\t\t\t\t\tox4 = ox5 + ( j4*sx[4] );\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdx4 = sx[4] - ( s3*sx[3] );\n\t\t\t\t\t\t\t\tox3 = ox4 + ( j3*sx[3] );\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdx3 = sx[3] - ( s2*sx[2] );\n\t\t\t\t\t\t\t\t\tox2 = ox3 + ( j2*sx[2] );\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdx2 = sx[2] - ( s1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tox1 = ox2 + ( j1*sx[1] );\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute the index offset for the first output ndarray element in the current block:\n\t\t\t\t\t\t\t\t\t\t\tix = ox1 + ( j0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Compute the loop offset increment:\n\t\t\t\t\t\t\t\t\t\t\tdx1 = sx[1] - ( s0*sx[0] );\n\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the ndarray dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn.call( thisArg, get( xbuf, ix ), take( [ i9, i8, i7, i6, i5, i4, i3, i2, i1, i0 ], idx ), x.ref );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx4;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tix += dx8;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tix += dx9;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedforEach10d;\n"],"names":["MODE","FOR_EACH","x","fcn","thisArg","call","data","offset","ref","xbuf","dx0","S0","ix","i0","shape","strides","dx1","idx","sh","S1","sx","i1","zeroTo","length","strides2order","reverse","take","dx2","S2","i2","dx3","S3","i3","dx4","S4","i4","dx5","S5","i5","dx6","S6","i6","dx7","S7","i7","dx8","S8","i8","dx9","S9","i9","ACCESSOR_FOR_EACH","accessors","get","BLOCKED_FOR_EACH","bsize","ox1","s0","s1","ox","j0","j1","o","loopOrder","blockSize","dtype","ox2","s2","j2","ox3","s3","j3","ox4","s4","j4","ox5","s5","j5","ox6","s6","j6","ox7","s7","j7","ox8","s8","j8","ox9","s9","j9","BLOCKED_ACCESSOR_FOR_EACH","MAX_DIMS","forEach","arrays","ndims","shx","ndarray2object","accessorProtocol","numel","iterationOrder","ordx","len","i","order","vind2bind","ind2sub","accessorForEachnd","forEachnd"],"mappings":"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"}